from typing import Any, Literal, TypedDict

# Define missing types
ResponseImageMimeTypes = Literal["image/jpeg", "image/png", "image/gif", "image/webp"]
ResponseDocumentMimeTypes = Literal[
    "application/pdf",
    "text/plain",
    "text/csv",
    "text/tab-separated-values",
    "text/markdown",
    "text/html",
    "application/vnd.ms-excel",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/msword",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
]


class ResponseImageContent(TypedDict):
    """Represents an image generated or referenced in a model's response.

    This class handles image content in various formats (URL, base64, raw bytes),
    with support for different resolutions and image formats. It provides
    validation and conversion utilities for working with image data.
    """

    mime_type: ResponseImageMimeTypes
    """MIME type of the image"""

    value: str | bytes
    """The image data - either a URL or base64 encoded string, or raw bytes"""

    kind: Literal["image"]
    """Content kind identifier, always 'image'"""

    sub_type: Literal["url", "base64", "raw_bytes"]
    """Format of the image data - either a URL or base64 encoded string, or raw bytes"""

    detail: Literal["low_res", "high_res"]
    """Resolution quality of the image"""


class ResponseDocumentContent(TypedDict):
    """Represents a document generated or referenced in a model's response.

    This class handles document content in various formats (URL, base64, raw bytes),
    supporting a wide range of document types including PDFs, text files, spreadsheets,
    and word processing documents. It provides validation and format handling for
    document data.
    """

    mime_type: ResponseDocumentMimeTypes
    """MIME type of the document"""

    value: str | bytes
    """The document data - either an agent-server UploadedFile, base64 encoded string,
    or raw bytes"""

    name: str
    """The name of the document"""

    kind: Literal["document"]
    """Content kind identifier, always 'document'"""

    sub_type: Literal["UploadedFile", "base64", "raw_bytes", "url"]
    """Format of the document data - either an agent-server UploadedFile, base64
    encoded string, raw bytes, or URL"""


class ResponseAudioContent(TypedDict):
    """Represents audio content generated or referenced in a model's response.

    This class handles audio content in various formats (URL, base64), supporting
    common audio formats like WAV and MP3. It provides validation for the audio data
    and ensures proper format handling.
    """

    mime_type: Literal["audio/wav", "audio/mp3"]
    """MIME type of the audio"""

    value: str
    """The base64 encoded audio data"""

    kind: Literal["audio"]
    """Content kind identifier, always 'audio'"""

    sub_type: Literal["base64", "url"]
    """Format of the audio data - url-based or base64-encoded"""


class ResponseTextContent(TypedDict):
    """Represents a text segment in a model's response.

    This class handles plain text content from the model's response, ensuring that
    the text is non-empty and properly typed.
    """

    text: str
    """The actual text content from the model"""

    kind: Literal["text"]
    """Content kind identifier, always 'text'"""


class ResponseToolUseContent(TypedDict):
    """Represents a tool use request generated by the model.

    This class handles tool usage requests from the model, normalizing input formats
    from different LLM providers (e.g., OpenAI, Claude) into a consistent structure.
    It provides validation and parsing of tool inputs while maintaining
    provider-specific compatibility.

    Raises:
        json.JSONDecodeError: If tool_input_raw is a string and cannot be parsed as
        valid JSON.
        AssertionError: If kind field doesn't match the literal "tool_use".
    """

    tool_call_id: str
    """Unique identifier for this tool call"""

    tool_name: str
    """Name of the tool being requested"""

    tool_input_raw: str
    """Raw tool input as a JSON string."""

    _tool_input: dict
    """Parsed tool input parameters as a dictionary"""

    kind: Literal["tool_use"]
    """Content kind identifier, always 'tool_use'"""


class TokenUsage(TypedDict):
    """Represents token usage statistics from a model's response.

    This class provides a structured format for tracking token consumption,
    including input, output, and total tokens used in a model interaction.
    """

    input_tokens: int
    """Number of input tokens processed by the model"""

    output_tokens: int
    """Number of output tokens generated by the model"""

    total_tokens: int
    """Total number of tokens (input + output) used in the interaction"""


AnyResponseMessageContent = (
    ResponseAudioContent
    | ResponseDocumentContent
    | ResponseImageContent
    | ResponseTextContent
    | ResponseToolUseContent
)


class ResponseMessage(TypedDict):
    """A response message from a language model hosted on a platform.

    This class represents a response message from a language model,
    providing a structured format for both content and metadata. It
    supports multi-modal content (text, images, audio, documents) and
    includes standardized fields for model metrics and usage data.
    """

    content: list[AnyResponseMessageContent]
    """The contents of the model's response."""

    role: Literal["agent"]
    """The role of the message sender."""

    raw_response: Any | None
    """The raw response from the model"""

    stop_reason: str | None
    """The reason why the response stopped (e.g., stop_sequence, max_tokens)"""

    usage: TokenUsage | None
    """Token usage statistics for the model interaction"""

    metrics: dict | None
    """Model performance metrics and timing information"""

    metadata: dict | None
    """Additional metadata about the response generation"""

    additional_response_fields: dict | None
    """Provider-specific response fields not covered by other attributes"""
