import React from 'react';
import { render, userEvent, waitFor } from '../../utils/test-utils';
import { describe, it, expect, beforeAll, afterAll, beforeEach, afterEach } from 'vitest';

import {
  Dialog,
  DialogTrigger,
  DialogContent,
  DialogTitle,
  DialogDescription,
} from '@/core/components/ui/Dialog';

describe('Dialog Animation Tests', () => {
  describe('Animation Duration - FR-UI-006', () => {
    it('Dialog animations complete in exactly 200ms per FR-UI-006', async () => {
      const { getByText, findByRole } = render(
        <Dialog>
          <DialogTrigger asChild>
            <button>Open Dialog</button>
          </DialogTrigger>
          <DialogContent>
            <DialogTitle>Animation Test</DialogTitle>
            <DialogDescription>Testing animation timing</DialogDescription>
          </DialogContent>
        </Dialog>,
      );

      await userEvent.click(getByText('Open Dialog'));
      const dialog = await findByRole('dialog');

      // Check for animation duration classes
      // Tailwind's duration-200 class sets animation-duration to 200ms
      const classes = dialog.className;

      // The dialog should have animation classes applied
      // Note: Radix UI Dialog uses data-state for animation control
      expect(dialog.getAttribute('data-state')).toBe('open');

      // Verify the dialog content is visible and has proper classes
      expect(dialog).toBeTruthy();
    });

    it('Dialog overlay has transition-opacity with appropriate duration', async () => {
      const { getByText, findByRole, container } = render(
        <Dialog>
          <DialogTrigger asChild>
            <button>Open Dialog</button>
          </DialogTrigger>
          <DialogContent>
            <DialogTitle>Overlay Test</DialogTitle>
          </DialogContent>
        </Dialog>,
      );

      await userEvent.click(getByText('Open Dialog'));
      await findByRole('dialog');

      // Find the overlay element
      const overlay = container.querySelector('[class*="backdrop-blur"]');
      expect(overlay).toBeTruthy();

      const overlayClasses = overlay?.className || '';
      // Check for transition-opacity (may include motion-reduce:transition-none)
      expect(overlayClasses).toMatch(/transition-opacity/);

      // Verify overlay is in open state
      expect(overlay?.getAttribute('data-state')).toBe('open');
    });

    it('Dialog content has proper animation timing classes', async () => {
      const { findByRole } = render(
        <Dialog defaultOpen>
          <DialogContent>
            <DialogTitle>Content Animation</DialogTitle>
            <DialogDescription>Testing animation timing</DialogDescription>
          </DialogContent>
        </Dialog>,
      );

      const dialog = await findByRole('dialog');
      expect(dialog).toBeTruthy();

      // Verify dialog is in open state for animations
      expect(dialog?.getAttribute('data-state')).toBe('open');
    });
  });

  describe('Data-State Transitions', () => {
    it('transitions data-state from closed to open', async () => {
      const { getByText, findByRole, queryByRole } = render(
        <Dialog>
          <DialogTrigger asChild>
            <button>Open Dialog</button>
          </DialogTrigger>
          <DialogContent>
            <DialogTitle>State Transition Test</DialogTitle>
          </DialogContent>
        </Dialog>,
      );

      // Initially closed (no dialog in DOM)
      expect(queryByRole('dialog')).toBeNull();

      // Open the dialog
      await userEvent.click(getByText('Open Dialog'));
      const dialog = await findByRole('dialog');

      // Should have data-state="open"
      expect(dialog.getAttribute('data-state')).toBe('open');
    });

    it('transitions data-state from open to closed', async () => {
      const { getByText, findByRole, queryByRole } = render(
        <Dialog>
          <DialogTrigger asChild>
            <button>Open Dialog</button>
          </DialogTrigger>
          <DialogContent>
            <DialogTitle>Close State Test</DialogTitle>
          </DialogContent>
        </Dialog>,
      );

      // Open the dialog
      await userEvent.click(getByText('Open Dialog'));
      const dialog = await findByRole('dialog');
      expect(dialog.getAttribute('data-state')).toBe('open');

      // Close the dialog
      const closeButton = getByText('×');
      await userEvent.click(closeButton);

      // Dialog should be removed from DOM after animation
      await waitFor(() => {
        expect(queryByRole('dialog')).toBeNull();
      });
    });

    it('overlay data-state matches content data-state', async () => {
      const { getByText, findByRole, container } = render(
        <Dialog>
          <DialogTrigger asChild>
            <button>Open Dialog</button>
          </DialogTrigger>
          <DialogContent>
            <DialogTitle>Overlay State Test</DialogTitle>
          </DialogContent>
        </Dialog>,
      );

      await userEvent.click(getByText('Open Dialog'));
      await findByRole('dialog');

      const overlay = container.querySelector('[class*="backdrop-blur"]');
      const dialog = container.querySelector('[role="dialog"]');

      // Both should be in open state
      expect(overlay?.getAttribute('data-state')).toBe('open');
      expect(dialog?.getAttribute('data-state')).toBe('open');
    });

    it('maintains data-state consistency during complete lifecycle', async () => {
      const { getByText, findByRole, queryByRole, container } = render(
        <Dialog>
          <DialogTrigger asChild>
            <button>Open Dialog</button>
          </DialogTrigger>
          <DialogContent>
            <DialogTitle>Lifecycle Test</DialogTitle>
          </DialogContent>
        </Dialog>,
      );

      // Closed state - no dialog in DOM
      expect(queryByRole('dialog')).toBeNull();

      // Open transition
      await userEvent.click(getByText('Open Dialog'));
      const dialog = await findByRole('dialog');
      expect(dialog.getAttribute('data-state')).toBe('open');

      // Close transition
      await userEvent.click(getByText('×'));

      // After closing, dialog is removed from DOM
      await waitFor(() => {
        expect(queryByRole('dialog')).toBeNull();
      });
    });
  });

  describe('Zoom and Fade Animations', () => {
    it('Dialog content has fade animation support', async () => {
      const { findByRole } = render(
        <Dialog defaultOpen>
          <DialogContent>
            <DialogTitle>Fade Animation</DialogTitle>
            <DialogDescription>Testing fade animations</DialogDescription>
          </DialogContent>
        </Dialog>,
      );

      const dialog = await findByRole('dialog');
      expect(dialog).toBeTruthy();

      // Dialog should be in open state, allowing CSS animations
      expect(dialog?.getAttribute('data-state')).toBe('open');
    });

    it('Dialog overlay has fade animation via transition-opacity', async () => {
      const { findByRole, container } = render(
        <Dialog defaultOpen>
          <DialogContent>
            <DialogTitle>Overlay Fade</DialogTitle>
            <DialogDescription>Testing overlay fade</DialogDescription>
          </DialogContent>
        </Dialog>,
      );

      await findByRole('dialog');

      const overlay = container.querySelector('[class*="backdrop-blur"]');
      const overlayClasses = overlay?.className || '';

      expect(overlayClasses).toMatch(/transition-opacity/);
      expect(overlay?.getAttribute('data-state')).toBe('open');
    });

    it('Dialog uses transform for centering (enables zoom animation)', async () => {
      const { findByRole } = render(
        <Dialog defaultOpen>
          <DialogContent>
            <DialogTitle>Transform Test</DialogTitle>
            <DialogDescription>Testing transforms</DialogDescription>
          </DialogContent>
        </Dialog>,
      );

      const dialog = await findByRole('dialog');
      const classes = dialog?.className || '';

      // Transform-based centering enables smooth zoom animations
      expect(classes).toContain('-translate-x-1/2');
      expect(classes).toContain('-translate-y-1/2');
    });
  });

  describe('Prefers-Reduced-Motion Support', () => {
    let originalMatchMedia: typeof window.matchMedia;

    beforeAll(() => {
      originalMatchMedia = window.matchMedia;
    });

    afterAll(() => {
      window.matchMedia = originalMatchMedia;
    });

    beforeEach(() => {
      // Reset to default (no reduced motion preference)
      window.matchMedia = (query: string) => ({
        matches: false,
        media: query,
        onchange: null,
        addListener: () => {},
        removeListener: () => {},
        addEventListener: () => {},
        removeEventListener: () => {},
        dispatchEvent: () => true,
      });
    });

    it('Dialog renders correctly with prefers-reduced-motion:reduce', async () => {
      // Mock prefers-reduced-motion: reduce
      window.matchMedia = (query: string) => ({
        matches: query === '(prefers-reduced-motion: reduce)',
        media: query,
        onchange: null,
        addListener: () => {},
        removeListener: () => {},
        addEventListener: () => {},
        removeEventListener: () => {},
        dispatchEvent: () => true,
      });

      const { getByText, findByRole } = render(
        <Dialog>
          <DialogTrigger asChild>
            <button>Open Dialog</button>
          </DialogTrigger>
          <DialogContent>
            <DialogTitle>Reduced Motion Test</DialogTitle>
            <DialogDescription>Testing motion preferences</DialogDescription>
          </DialogContent>
        </Dialog>,
      );

      await userEvent.click(getByText('Open Dialog'));
      const dialog = await findByRole('dialog');

      // Dialog should still render and function correctly
      expect(dialog).toBeTruthy();
      expect(getByText('Reduced Motion Test')).toBeTruthy();

      // The motion-reduce behavior is handled by Tailwind CSS
      // Components should still have proper data-state for CSS control
      expect(dialog.getAttribute('data-state')).toBe('open');
    });

    it('Dialog overlay respects reduced motion preferences', async () => {
      window.matchMedia = (query: string) => ({
        matches: query === '(prefers-reduced-motion: reduce)',
        media: query,
        onchange: null,
        addListener: () => {},
        removeListener: () => {},
        addEventListener: () => {},
        removeEventListener: () => {},
        dispatchEvent: () => true,
      });

      const { container } = render(
        <Dialog defaultOpen>
          <DialogContent>
            <DialogTitle>Overlay Motion Test</DialogTitle>
          </DialogContent>
        </Dialog>,
      );

      await waitFor(() => {
        const overlay = container.querySelector('[class*="backdrop-blur"]');
        expect(overlay).toBeTruthy();

        // Overlay should still have transition classes with motion-reduce support
        // The motion-reduce utility will disable animations at CSS level
        const overlayClasses = overlay?.className || '';
        expect(overlayClasses).toMatch(/transition-opacity/);
        // Verify motion-reduce class is present
        expect(overlayClasses).toContain('motion-reduce:transition-none');
      });
    });

    it('Dialog functions correctly when toggling between motion preferences', async () => {
      // Start with no motion preference
      const { getByText, findByRole, queryByRole } = render(
        <Dialog>
          <DialogTrigger asChild>
            <button>Open Dialog</button>
          </DialogTrigger>
          <DialogContent>
            <DialogTitle>Toggle Motion Test</DialogTitle>
          </DialogContent>
        </Dialog>,
      );

      // Open with normal animations
      await userEvent.click(getByText('Open Dialog'));
      let dialog = await findByRole('dialog');
      expect(dialog.getAttribute('data-state')).toBe('open');

      // Close
      await userEvent.click(getByText('×'));
      await waitFor(() => {
        expect(queryByRole('dialog')).toBeNull();
      });

      // Simulate reduced motion preference
      window.matchMedia = (query: string) => ({
        matches: query === '(prefers-reduced-motion: reduce)',
        media: query,
        onchange: null,
        addListener: () => {},
        removeListener: () => {},
        addEventListener: () => {},
        removeEventListener: () => {},
        dispatchEvent: () => true,
      });

      // Open again with reduced motion
      await userEvent.click(getByText('Open Dialog'));
      dialog = await findByRole('dialog');
      expect(dialog).toBeTruthy();
      expect(dialog.getAttribute('data-state')).toBe('open');
    });

    it('motion-reduce classes should be applied when appropriate', async () => {
      window.matchMedia = (query: string) => ({
        matches: query === '(prefers-reduced-motion: reduce)',
        media: query,
        onchange: null,
        addListener: () => {},
        removeListener: () => {},
        addEventListener: () => {},
        removeEventListener: () => {},
        dispatchEvent: () => true,
      });

      const { container } = render(
        <Dialog defaultOpen>
          <DialogContent>
            <DialogTitle>Motion Reduce Classes</DialogTitle>
          </DialogContent>
        </Dialog>,
      );

      await waitFor(() => {
        const dialog = container.querySelector('[role="dialog"]');
        const overlay = container.querySelector('[class*="backdrop-blur"]');

        expect(dialog).toBeTruthy();
        expect(overlay).toBeTruthy();

        // Verify motion-reduce classes are present on overlay
        const overlayClasses = overlay?.className || '';
        expect(overlayClasses).toContain('motion-reduce:transition-none');

        // Check close button has motion-reduce support
        const closeButton = Array.from(container.querySelectorAll('button')).find(
          (btn) => btn.textContent?.includes('×')
        );
        const closeButtonClasses = closeButton?.className || '';
        expect(closeButtonClasses).toContain('motion-reduce:transition-none');

        // Note: The actual motion-reduce:animate-none behavior is handled by Tailwind CSS
        // at the stylesheet level. This test verifies the component structure supports it.
        expect(dialog?.getAttribute('data-state')).toBe('open');
      });
    });
  });

  describe('Animation Transition Classes', () => {
    it('Dialog content maintains proper positioning during animations', async () => {
      const { container } = render(
        <Dialog defaultOpen>
          <DialogContent>
            <DialogTitle>Positioning Test</DialogTitle>
          </DialogContent>
        </Dialog>,
      );

      await waitFor(() => {
        const dialog = container.querySelector('[role="dialog"]');
        const classes = dialog?.className || '';

        // Fixed positioning with transforms
        expect(classes).toContain('fixed');
        expect(classes).toContain('left-1/2');
        expect(classes).toContain('top-1/2');
        expect(classes).toContain('-translate-x-1/2');
        expect(classes).toContain('-translate-y-1/2');
      });
    });

    it('Dialog overlay has correct z-index stacking', async () => {
      const { container } = render(
        <Dialog defaultOpen>
          <DialogContent>
            <DialogTitle>Z-Index Test</DialogTitle>
          </DialogContent>
        </Dialog>,
      );

      await waitFor(() => {
        const overlay = container.querySelector('[class*="backdrop-blur"]');
        const dialog = container.querySelector('[role="dialog"]');

        const overlayClasses = overlay?.className || '';
        const dialogClasses = dialog?.className || '';

        // Overlay should be z-40, dialog content z-50
        expect(overlayClasses).toContain('z-40');
        expect(dialogClasses).toContain('z-50');
      });
    });

    it('Dialog maintains backdrop blur throughout animation lifecycle', async () => {
      const { getByText, container, queryByRole } = render(
        <Dialog>
          <DialogTrigger asChild>
            <button>Open Dialog</button>
          </DialogTrigger>
          <DialogContent>
            <DialogTitle>Backdrop Blur Test</DialogTitle>
          </DialogContent>
        </Dialog>,
      );

      // Open
      await userEvent.click(getByText('Open Dialog'));

      await waitFor(() => {
        const overlay = container.querySelector('[class*="backdrop-blur"]');
        const overlayClasses = overlay?.className || '';

        expect(overlayClasses).toContain('backdrop-blur-sm');
        expect(overlayClasses).toContain('bg-black/40');
      });

      // During open state
      const overlay = container.querySelector('[class*="backdrop-blur"]');
      expect(overlay?.getAttribute('data-state')).toBe('open');
    });

    it('Dialog close button transitions are smooth', async () => {
      const { container } = render(
        <Dialog defaultOpen>
          <DialogContent>
            <DialogTitle>Close Button Test</DialogTitle>
          </DialogContent>
        </Dialog>,
      );

      await waitFor(() => {
        // Find the close button (the × button)
        const closeButton = Array.from(container.querySelectorAll('button')).find(
          (btn) => btn.textContent?.includes('×')
        );

        expect(closeButton).toBeTruthy();

        const classes = closeButton?.className || '';
        expect(classes).toContain('transition-colors');
      });
    });
  });

  describe('Animation Performance', () => {
    it('Dialog uses GPU-accelerated properties for animations', async () => {
      const { container } = render(
        <Dialog defaultOpen>
          <DialogContent>
            <DialogTitle>Performance Test</DialogTitle>
          </DialogContent>
        </Dialog>,
      );

      await waitFor(() => {
        const dialog = container.querySelector('[role="dialog"]');
        const overlay = container.querySelector('[class*="backdrop-blur"]');

        const dialogClasses = dialog?.className || '';
        const overlayClasses = overlay?.className || '';

        // Transform (GPU-accelerated)
        expect(dialogClasses).toContain('-translate-x-1/2');
        expect(dialogClasses).toContain('-translate-y-1/2');

        // Opacity transitions (GPU-accelerated)
        expect(overlayClasses).toContain('transition-opacity');

        // Backdrop filters (GPU-accelerated when supported)
        expect(overlayClasses).toContain('backdrop-blur-sm');
      });
    });

    it('Dialog does not use layout-affecting properties in animations', async () => {
      const { container } = render(
        <Dialog defaultOpen>
          <DialogContent>
            <DialogTitle>Layout Test</DialogTitle>
          </DialogContent>
        </Dialog>,
      );

      await waitFor(() => {
        const dialog = container.querySelector('[role="dialog"]');
        const overlay = container.querySelector('[class*="backdrop-blur"]');

        const dialogClasses = dialog?.className || '';
        const overlayClasses = overlay?.className || '';

        // Should not have transition-all (too expensive)
        expect(dialogClasses).not.toContain('transition-all');
        expect(overlayClasses).not.toContain('transition-all');

        // Should use specific, performant transitions
        expect(overlayClasses).toMatch(/transition-opacity/);
      });
    });

    it('Dialog animations complete quickly to maintain 60fps', async () => {
      const { getByText, findByRole } = render(
        <Dialog>
          <DialogTrigger asChild>
            <button>Open Dialog</button>
          </DialogTrigger>
          <DialogContent>
            <DialogTitle>FPS Test</DialogTitle>
          </DialogContent>
        </Dialog>,
      );

      const startTime = performance.now();
      await userEvent.click(getByText('Open Dialog'));
      await findByRole('dialog');
      const endTime = performance.now();

      // Animation should complete in reasonable time (200ms + rendering overhead)
      // We allow more time for test environment overhead
      expect(endTime - startTime).toBeLessThan(1000);
    });
  });

  describe('Animation Edge Cases', () => {
    it('handles rapid open/close cycles gracefully', async () => {
      const { getByText, findByRole, queryByRole } = render(
        <Dialog>
          <DialogTrigger asChild>
            <button>Toggle Dialog</button>
          </DialogTrigger>
          <DialogContent>
            <DialogTitle>Rapid Toggle Test</DialogTitle>
          </DialogContent>
        </Dialog>,
      );

      const button = getByText('Toggle Dialog');

      // Rapid open
      await userEvent.click(button);
      await findByRole('dialog');

      // Rapid close
      await userEvent.click(getByText('×'));

      // Open again quickly
      await userEvent.click(button);
      const dialog = await findByRole('dialog');

      expect(dialog).toBeTruthy();
      expect(dialog.getAttribute('data-state')).toBe('open');
    });

    it('maintains animation state with controlled open prop', async () => {
      const TestComponent = () => {
        const [open, setOpen] = React.useState(false);

        return (
          <>
            <button onClick={() => setOpen(!open)}>Toggle</button>
            <Dialog open={open} onOpenChange={setOpen}>
              <DialogContent>
                <DialogTitle>Controlled Animation</DialogTitle>
              </DialogContent>
            </Dialog>
          </>
        );
      };

      const { getByText, findByRole, queryByRole, container } = render(<TestComponent />);

      expect(queryByRole('dialog')).toBeNull();

      // Get the toggle button (it's outside the dialog so no pointer-events issue)
      const toggleButton = getByText('Toggle');

      // Open
      await userEvent.click(toggleButton);
      const dialog = await findByRole('dialog');
      expect(dialog.getAttribute('data-state')).toBe('open');

      // Close via close button instead of toggle (avoid pointer-events issues)
      const closeButton = container.querySelector('button[class*="absolute"]');
      if (closeButton) {
        await userEvent.click(closeButton as HTMLElement);
      }

      await waitFor(() => {
        expect(queryByRole('dialog')).toBeNull();
      });
    });

    it('handles defaultOpen with proper animation state', async () => {
      const { findByRole } = render(
        <Dialog defaultOpen>
          <DialogContent>
            <DialogTitle>Default Open Test</DialogTitle>
          </DialogContent>
        </Dialog>,
      );

      // Dialog should be open immediately with proper state
      const dialog = await findByRole('dialog');
      expect(dialog.getAttribute('data-state')).toBe('open');
    });
  });
});
