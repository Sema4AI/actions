import os
import sys
from contextlib import contextmanager
from pathlib import Path
from typing import Optional

ROOT = Path(__file__).absolute().parent

try:
    import devutils
except ImportError:
    devutils_src = ROOT.parent / "devutils" / "src"
    assert devutils_src.exists(), f"{devutils_src} does not exist!"
    sys.path.append(str(devutils_src))

from devutils.invoke_utils import build_common_tasks

globals().update(
    build_common_tasks(
        ROOT,
        "sema4ai.action_server",
        ruff_format_arguments=r"--exclude=_static_contents.py,_oauth2_config.py",
    )
)

from invoke import Context, task

CURDIR = Path(__file__).parent.absolute()


@contextmanager
def chdir(path: Path):
    old = Path.cwd()
    try:
        os.chdir(path)
        yield
    finally:
        os.chdir(old)


def run(ctx: Context, *args: str, **options):
    cmd = " ".join(args)
    options.setdefault("pty", sys.platform != "win32")
    options.setdefault("echo", True)
    ctx.run(cmd, **options)


@contextmanager
def _change_to_frontend_dir():
    RESOLVED_CURDIR = CURDIR.resolve()

    # vite build has a bug which makes it misbehave when working with a subst
    # (presumably this is because it's resolving the actual location of
    # things and then compares with unresolved paths).
    # In order to fix that we resolve the directory ourselves prior to the
    # build and switch to that directory.
    with chdir(RESOLVED_CURDIR / "frontend"):
        yield


@contextmanager
def _change_to_build_binary():
    RESOLVED_CURDIR = CURDIR.absolute()

    with chdir(RESOLVED_CURDIR / "build-binary"):
        yield


@contextmanager
def _change_to_build_go_wrapper():
    RESOLVED_CURDIR = CURDIR.absolute()

    with chdir(RESOLVED_CURDIR / "go-wrapper"):
        yield


@task
def dev_frontend(ctx: Context):
    """Run the frontend in dev mode (starts its own localhost server using vite)."""

    with _change_to_frontend_dir():
        run(ctx, "npm", "run", "dev")


@task
def build_frontend(ctx: Context, debug: bool = False, install: bool = True):
    """Build static .html frontend"""

    with _change_to_frontend_dir():
        if install:
            run(ctx, "npm", "ci", "--no-audit", "--no-fund")
        if debug:
            run(ctx, "npm", "run", "build:debug")
        else:
            run(ctx, "npm", "run", "build")

    index_src = CURDIR / "frontend" / "dist" / "index.html"
    assert index_src.exists(), f"Expected: {index_src} to exist."
    dest_static_contents = (
        CURDIR / "src" / "sema4ai" / "action_server" / "_static_contents.py"
    )

    file_contents = {"index.html": index_src.read_bytes()}

    with open(dest_static_contents, "w", encoding="utf-8") as stream:
        print(f"Writing static contents to: {dest_static_contents}")
        stream.write(
            f"""# coding: utf-8
# Note: autogenerated file.
# To regenerate this file use: inv built-frontend.

# The FILE_CONTENTS contains the contents of the files with
# html/javascript code for the static assets we use.

FILE_CONTENTS = {repr(file_contents)}
"""
        )


@task
def build_frontend_cdn(ctx: Context, version: str = "latest"):
    """Build static .html frontend from CDN (bypasses npm dependencies)"""
    import subprocess
    import time
    import requests
    
    print(f"Building frontend from CDN (version: {version})...")
    
    # Download the Linux binary
    binary_url = f"https://cdn.sema4.ai/action-server/releases/{version}/linux64/action-server"
    temp_dir = CURDIR / "temp_cdn_extract"
    temp_dir.mkdir(exist_ok=True)
    
    try:
        binary_path = temp_dir / "action-server"
        print(f"Downloading binary from {binary_url}...")
        response = requests.get(binary_url, stream=True)
        response.raise_for_status()
        
        with open(binary_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
        
        os.chmod(binary_path, 0o755)
        
        # Create minimal package
        (temp_dir / "package.yaml").write_text("""name: temp-package
description: Temporary package for extracting frontend
version: 0.1.0""")
        
        (temp_dir / "dummy_action.py").write_text("""from sema4ai.actions import action
@action
def dummy():
    return "dummy"
""")
        
        # Start server
        process = subprocess.Popen(
            [str(binary_path), "start", "--port", "8080"],
            cwd=str(temp_dir),
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        
        # Wait for server
        print("Waiting for server to start...")
        for i in range(30):
            try:
                response = requests.get("http://localhost:8080/")
                if response.status_code == 200:
                    break
            except requests.ConnectionError:
                pass
            time.sleep(1)
        
        # Download frontend
        response = requests.get("http://localhost:8080/")
        response.raise_for_status()
        html_content = response.content
        
        # Write to file
        dest_static_contents = (
            CURDIR / "src" / "sema4ai" / "action_server" / "_static_contents.py"
        )
        file_contents = {"index.html": html_content}
        with open(dest_static_contents, "w", encoding="utf-8") as stream:
            print(f"Writing static contents to: {dest_static_contents}")
            stream.write(
                f"""# coding: utf-8
# Note: autogenerated file from CDN.
# To regenerate this file use: inv build-frontend-cdn.
# The FILE_CONTENTS contains the contents of the files with
# html/javascript code for the static assets we use.
FILE_CONTENTS = {repr(file_contents)}
"""
            )
        print("Frontend successfully extracted from CDN!")
        
    finally:
        # Cleanup
        if 'process' in locals():
            process.terminate()
            process.wait()
        if temp_dir.exists():
            shutil.rmtree(temp_dir)


@task
def build_oauth2_config(ctx: Context):
    """Build static OAuth2 .yaml config."""
    import subprocess

    sema4ai_config_file_name = "sema4ai-oauth-config.yaml"
    default_user_config_file_name = "oauth-config.yaml"
    sema4ai_config_local_file_path = CURDIR / sema4ai_config_file_name
    default_user_config_local_file_path = CURDIR / default_user_config_file_name

    base_api_url = "repos/Sema4AI/oauth-public-configs/contents"

    dest_path = CURDIR / "src" / "sema4ai" / "action_server" / "_oauth2_config.py"

    result_sema4ai_config_contents = subprocess.run(
        [
            "gh",
            "api",
            "-H",
            "Accept: application/vnd.github.raw",
            f"{base_api_url}/{sema4ai_config_file_name}",
        ],
        stdout=subprocess.PIPE,
    ).stdout.decode("utf-8")

    default_user_config_contents = subprocess.run(
        [
            "gh",
            "api",
            "-H",
            "Accept: application/vnd.github.raw",
            f"{base_api_url}/{default_user_config_file_name}",
        ],
        stdout=subprocess.PIPE,
    ).stdout.decode("utf-8")

    file_contents = {
        "sema4ai_config": result_sema4ai_config_contents,
        "default_user_config": default_user_config_contents,
    }

    with open(dest_path, "w", encoding="utf-8") as stream:
        print(f"Writing OAuth2 configs to: {dest_path}")
        stream.write(
            f"""# coding: utf-8
# Note: autogenerated file.
# To regenerate this file use: inv build-oauth2-config.

# The FILE_CONTENTS contains the contents of the Sema4.ai OAuth2 configuration, as well as default user configuration.

FILE_CONTENTS = {repr(file_contents)}
"""
        )


@task(
    help={
        "debug": "Build in debug mode",
        "ci": "Build in CI mode, disabling interactive prompts",
        "dist_path": "Path to the dist directory",
        "sign": "Sign the executable",
        "go_wrapper": "Build the Go wrapper too",
        "version": "Version of the executable (gotten from github tag/pr if not passed)",
    }
)
def build_executable(
    ctx: Context,
    debug: bool = False,
    ci: bool = True,
    dist_path: str = "dist",
    sign: bool = False,
    go_wrapper: bool = False,
    version: str = None,
    go_wrapper_name: str | None = None,
) -> None:
    """Build the project executable via PyInstaller."""
    from sema4ai.build_common.root_dir import get_root_dir
    from sema4ai.build_common.workflows import build_and_sign_executable

    if version is None:
        from sema4ai.action_server import __version__

        version = __version__

    root_dir = get_root_dir()
    build_and_sign_executable(
        root_dir=root_dir,
        name="action-server",
        debug=debug,
        ci=ci,
        dist_path=root_dir / dist_path,
        sign=sign,
        go_wrapper=go_wrapper,
        version=version,
        go_wrapper_name=go_wrapper_name,
    )

    # to check if signed:  spctl -a -vvv -t install dist/final/action-server


@task
def clean(ctx: Context):
    """Clean build artifacts."""
    from sema4ai.build_common.root_dir import get_root_dir
    from sema4ai.build_common.workflows import clean_common_build_artifacts

    clean_common_build_artifacts(get_root_dir())


@task
def build_go_wrapper(ctx: Context) -> None:
    with _change_to_build_go_wrapper():
        target = "action-server-unsigned" + (".exe" if sys.platform == "win32" else "")
        run(
            ctx,
            "go",
            "build",
            "-o",
            target,
        )
        print(f"Built go wrapper at: {os.path.abspath(target)}")


@task
def download_rcc(ctx: Context, system: Optional[str] = None) -> None:
    """
    Downloads RCC in the place where the action server expects it
    """
    env = os.environ.copy()
    curr_pythonpath = env.get("PYTHONPATH", "")
    env["PYTHONPATH"] = curr_pythonpath + os.pathsep + str(CURDIR / "src")
    run(ctx, "python -m sema4ai.action_server download-rcc", env=env)


def _replace_deps(content, new_deps):
    """Replaces the contents between ## START DEPS and ## ENDS DEPS with new_deps.

    Args:
      content: The content of the file as a string.
      new_deps: The new dependencies to insert.

    Returns:
      The content of the file with the dependencies replaced.
    """

    start_marker = "## START DEPS\n"
    end_marker = "## END DEPS\n"

    start_pos = content.find(start_marker)
    end_pos = content.find(end_marker)

    if start_pos == -1 or end_pos == -1:
        raise ValueError("Markers not found in content")

    return content[:start_pos] + start_marker + new_deps + content[end_pos:]


@task
def test_not_integration(ctx: Context):
    from sema4ai.build_common.process_call import run
    from sema4ai.build_common.root_dir import get_root_dir

    action_server_dir = get_root_dir()
    run(
        [
            sys.executable,
            "-m",
            "pytest",
            "-m",
            "not integration_test",
            "-rfE",
            "-vv",
            "--force-regen",
            "-n",
            "auto",
        ],
        cwd=str(action_server_dir / "tests"),
    )


@task
def test_binary(ctx: Context, test: str = "", jobs: str = "auto"):
    """Test the binary"""
    import subprocess

    from sema4ai.build_common.process_call import run
    from sema4ai.build_common.root_dir import get_root_dir

    # The binary should be in the dist directory already.
    # Run all the tests using pytest -m integration_test
    # While setting an environment variable to point to the
    # created executable.
    action_server_dir = get_root_dir()
    action_server_executable = (
        action_server_dir
        / "dist"
        / "final"
        / ("action-server" + (".exe" if sys.platform == "win32" else ""))
    )
    assert (
        action_server_executable.exists()
    ), f"Expected: {action_server_executable} to exist."
    env = os.environ.copy()
    env.pop("PYTHONPATH", "")
    env.pop("PYTHONHOME", "")
    env.pop("VIRTUAL_ENV", "")
    env["PYTHONIOENCODING"] = "utf-8"
    env["PYTHON_EXE"] = str(sys.executable)

    env["SEMA4AI_INTEGRATION_TEST_ACTION_SERVER_EXECUTABLE"] = str(
        action_server_executable
    )
    args = [
        sys.executable,
        "-m",
        "pytest",
        "-m",
        "integration_test",
        "-rfE",
        "-vv",
        "--force-regen",
        "-n",
        "0",  # Bad rcc: when we run too many rcc tests in parallel from the binary, tests fail because rcc seems to crash (needs more investigation)
    ]
    if test:
        args.append("-k")
        args.append(test)
    run(
        args,
        cwd=str(action_server_dir / "tests"),
        env=env,
    )


@task
def print_env(ctx: Context):
    import os

    print(" ============== ENV ============== ")
    for key, value in os.environ.items():
        if len(value) > 100:
            print(f"{key}:")
            parts = value.split(os.pathsep)
            for part in parts:
                print(f"  {part}")
        else:
            print(f"{key}={value}")
    print(" ============== END ENV ============== ")


@task
def test_run_in_parallel(ctx: Context):
    """
    Just runs the action server in dist/final/action-server 3 times in parallel
    (may be used to manually check issues with the lock file).
    """
    import subprocess

    from sema4ai.build_common.process_call import run
    from sema4ai.build_common.root_dir import get_root_dir

    # The binary should be in the dist directory already.
    action_server_dir = get_root_dir()
    action_server_executable = (
        action_server_dir
        / "dist"
        / "final"
        / ("action-server" + (".exe" if sys.platform == "win32" else ""))
    )
    assert (
        action_server_executable.exists()
    ), f"Expected: {action_server_executable} to exist."
    subprocess.Popen([action_server_executable, "-h"])
    subprocess.Popen([action_server_executable, "-h"])
    subprocess.Popen([action_server_executable, "-h"])
